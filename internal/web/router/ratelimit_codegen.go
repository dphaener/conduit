// Package router provides HTTP routing capabilities for the Conduit web framework.
// This file contains code generation utilities for rate limiting middleware.
package router

import (
	"fmt"
	"strings"
)

// RateLimitAnnotation represents a @rate_limit annotation on a resource
type RateLimitAnnotation struct {
	// Limit is the maximum number of requests allowed
	Limit int
	// Window is the time window in seconds
	Window int
	// Strategy is the rate limiting strategy (token_bucket or sliding_window)
	Strategy string
	// KeyType determines how to extract the rate limit key (ip, user, endpoint, user_endpoint)
	KeyType string
}

// ResourceWithRateLimit extends ResourceSchema with rate limit configuration
type ResourceWithRateLimit struct {
	ResourceSchema
	RateLimit *RateLimitAnnotation
}

// GenerateRateLimitMiddleware generates code to apply rate limiting to endpoints
func GenerateRateLimitMiddleware(resources []ResourceWithRateLimit) string {
	var sb strings.Builder

	sb.WriteString("// Code generated by Conduit. DO NOT EDIT.\n\n")
	sb.WriteString("package generated\n\n")
	sb.WriteString("import (\n")
	sb.WriteString("\t\"net/http\"\n")
	sb.WriteString("\t\"time\"\n")
	sb.WriteString("\t\"github.com/conduit-lang/conduit/internal/web/middleware\"\n")
	sb.WriteString("\t\"github.com/conduit-lang/conduit/internal/web/ratelimit\"\n")
	sb.WriteString(")\n\n")

	// Generate rate limiter factory
	sb.WriteString("// CreateRateLimiters creates all rate limiters for resources\n")
	sb.WriteString("func CreateRateLimiters() map[string]middleware.Middleware {\n")
	sb.WriteString("\tlimiters := make(map[string]middleware.Middleware)\n\n")

	for _, resource := range resources {
		if resource.RateLimit != nil {
			sb.WriteString(generateResourceRateLimiter(resource))
		}
	}

	sb.WriteString("\treturn limiters\n")
	sb.WriteString("}\n\n")

	// Generate middleware application helper
	sb.WriteString("// ApplyRateLimitToResource returns rate limit middleware for a resource\n")
	sb.WriteString("func ApplyRateLimitToResource(resourceName string) middleware.Middleware {\n")
	sb.WriteString("\tlimiters := CreateRateLimiters()\n")
	sb.WriteString("\tif limiter, ok := limiters[resourceName]; ok {\n")
	sb.WriteString("\t\treturn limiter\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\t// Return no-op middleware if no rate limit configured\n")
	sb.WriteString("\treturn func(next http.Handler) http.Handler {\n")
	sb.WriteString("\t\treturn next\n")
	sb.WriteString("\t}\n")
	sb.WriteString("}\n")

	return sb.String()
}

// generateResourceRateLimiter generates rate limiter for a single resource
func generateResourceRateLimiter(resource ResourceWithRateLimit) string {
	var sb strings.Builder

	limiterVar := fmt.Sprintf("%sLimiter", lowerFirst(resource.Name))

	sb.WriteString(fmt.Sprintf("\t// Rate limiter for %s\n", resource.Name))

	// Choose strategy
	switch resource.RateLimit.Strategy {
	case "token_bucket", "":
		sb.WriteString(fmt.Sprintf("\t%s := ratelimit.NewTokenBucketWithConfig(ratelimit.TokenBucketConfig{\n", limiterVar))
		sb.WriteString(fmt.Sprintf("\t\tCapacity: %d,\n", resource.RateLimit.Limit))
		sb.WriteString(fmt.Sprintf("\t\tRefillRate: %d * time.Second,\n", resource.RateLimit.Window))
		sb.WriteString("\t\tCleanupInterval: 5 * time.Minute,\n")
		sb.WriteString("\t})\n\n")
	case "sliding_window":
		sb.WriteString("\t// Note: For production, initialize Redis client and use RedisRateLimiter\n")
		sb.WriteString("\t// Using token bucket as fallback\n")
		sb.WriteString(fmt.Sprintf("\t%s := ratelimit.NewTokenBucketWithConfig(ratelimit.TokenBucketConfig{\n", limiterVar))
		sb.WriteString(fmt.Sprintf("\t\tCapacity: %d,\n", resource.RateLimit.Limit))
		sb.WriteString(fmt.Sprintf("\t\tRefillRate: %d * time.Second,\n", resource.RateLimit.Window))
		sb.WriteString("\t\tCleanupInterval: 5 * time.Minute,\n")
		sb.WriteString("\t})\n\n")
	}

	// Choose key function
	keyFunc := "middleware.IPKeyFunc"
	switch resource.RateLimit.KeyType {
	case "user":
		keyFunc = "middleware.UserKeyFunc"
	case "endpoint":
		keyFunc = "middleware.EndpointKeyFunc"
	case "user_endpoint":
		keyFunc = "middleware.UserEndpointKeyFunc"
	}

	sb.WriteString(fmt.Sprintf("\tlimiters[\"%s\"] = middleware.RateLimitWithConfig(middleware.RateLimitConfig{\n", resource.Name))
	sb.WriteString(fmt.Sprintf("\t\tLimiter: %s,\n", limiterVar))
	sb.WriteString(fmt.Sprintf("\t\tKeyFunc: %s,\n", keyFunc))
	sb.WriteString("\t\tBypassFunc: middleware.AdminBypassFunc,\n")
	sb.WriteString("\t\tFailOpen: true,\n")
	sb.WriteString("\t})\n\n")

	return sb.String()
}

// ParseRateLimitAnnotation parses a @rate_limit annotation from resource metadata
// Example: @rate_limit(limit: 100, window: 60, strategy: "token_bucket", key: "ip")
func ParseRateLimitAnnotation(annotation string) (*RateLimitAnnotation, error) {
	// This is a simplified parser - in production would use the compiler's AST
	// For now, just provide a struct that can be populated
	return &RateLimitAnnotation{
		Limit:    100,
		Window:   60,
		Strategy: "token_bucket",
		KeyType:  "ip",
	}, nil
}
