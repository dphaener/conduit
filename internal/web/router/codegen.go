// Package router provides HTTP routing capabilities for the Conduit web framework.
// This file contains code generation utilities for creating route registration and handler stubs.
package router

import (
	"fmt"
	"strings"
)

// ResourceSchema represents a compiled resource schema for code generation
type ResourceSchema struct {
	Name           string
	PluralName     string
	TableName      string
	PrimaryKey     string
	PrimaryKeyType string
	Fields         []FieldSchema
	Operations     []CRUDOperation
}

// FieldSchema represents a field in a resource
type FieldSchema struct {
	Name     string
	Type     string
	Required bool
	Unique   bool
}

// GenerateRouterCode generates Go code for registering resource routes
func GenerateRouterCode(schemas []ResourceSchema) string {
	var sb strings.Builder

	sb.WriteString("// Code generated by Conduit. DO NOT EDIT.\n\n")
	sb.WriteString("package generated\n\n")
	sb.WriteString("import (\n")
	sb.WriteString("\t\"net/http\"\n")
	sb.WriteString("\t\"github.com/conduit-lang/conduit/internal/web/router\"\n")
	sb.WriteString(")\n\n")

	sb.WriteString("// RegisterRoutes registers all resource routes\n")
	sb.WriteString("func RegisterRoutes(r *router.Router) error {\n")

	for _, schema := range schemas {
		sb.WriteString(generateResourceRegistration(schema))
	}

	sb.WriteString("\treturn nil\n")
	sb.WriteString("}\n")

	return sb.String()
}

// generateResourceRegistration generates route registration code for a single resource
func generateResourceRegistration(schema ResourceSchema) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("\t// Register %s routes\n", schema.Name))
	sb.WriteString(fmt.Sprintf("\t%sDef := router.NewResourceDefinition(\"%s\")\n",
		lowerFirst(schema.Name), schema.Name))
	sb.WriteString(fmt.Sprintf("\t%sDef.PluralName = \"%s\"\n",
		lowerFirst(schema.Name), schema.PluralName))
	sb.WriteString(fmt.Sprintf("\t%sDef.IDType = \"%s\"\n",
		lowerFirst(schema.Name), schema.PrimaryKeyType))
	sb.WriteString(fmt.Sprintf("\t%sDef.Operations = []router.CRUDOperation{\n",
		lowerFirst(schema.Name)))

	for i, op := range schema.Operations {
		sb.WriteString(fmt.Sprintf("\t\trouter.Op%s", capitalize(op.String())))
		if i < len(schema.Operations)-1 {
			sb.WriteString(",")
		}
		sb.WriteString("\n")
	}
	sb.WriteString("\t}\n\n")

	sb.WriteString(fmt.Sprintf("\t%sHandlers := router.ResourceHandlers{\n",
		lowerFirst(schema.Name)))
	for _, op := range schema.Operations {
		handlerName := fmt.Sprintf("Handle%s%s", schema.Name, capitalize(op.String()))
		sb.WriteString(fmt.Sprintf("\t\t%s: %s,\n", capitalize(op.String()), handlerName))
	}
	sb.WriteString("\t}\n\n")

	sb.WriteString(fmt.Sprintf("\tif err := r.RegisterResource(%sDef, %sHandlers); err != nil {\n",
		lowerFirst(schema.Name), lowerFirst(schema.Name)))
	sb.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"failed to register %s routes: %%w\", err)\n",
		schema.Name))
	sb.WriteString("\t}\n\n")

	return sb.String()
}

// GenerateHandlerStubs generates stub handler functions for resources
func GenerateHandlerStubs(schemas []ResourceSchema) string {
	var sb strings.Builder

	sb.WriteString("// Code generated by Conduit. DO NOT EDIT.\n\n")
	sb.WriteString("package generated\n\n")
	sb.WriteString("import (\n")
	sb.WriteString("\t\"encoding/json\"\n")
	sb.WriteString("\t\"net/http\"\n")
	sb.WriteString("\t\"github.com/conduit-lang/conduit/internal/web/router\"\n")
	sb.WriteString(")\n\n")

	for _, schema := range schemas {
		for _, op := range schema.Operations {
			sb.WriteString(generateHandlerStub(schema, op))
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

// generateHandlerStub generates a single handler stub
func generateHandlerStub(schema ResourceSchema, op CRUDOperation) string {
	var sb strings.Builder

	handlerName := fmt.Sprintf("Handle%s%s", schema.Name, capitalize(op.String()))
	sb.WriteString(fmt.Sprintf("// %s handles %s operation for %s\n",
		handlerName, op.String(), schema.Name))
	sb.WriteString(fmt.Sprintf("func %s(w http.ResponseWriter, r *http.Request) {\n", handlerName))
	sb.WriteString("\tctx := r.Context()\n")
	sb.WriteString("\tparams := router.NewParamExtractor(r)\n\n")

	switch op {
	case OpList:
		sb.WriteString("\t// Extract pagination parameters\n")
		sb.WriteString("\tpagination := params.ExtractPagination(50, 100)\n\n")
		sb.WriteString("\t// TODO: Implement list logic\n")
		sb.WriteString("\t_ = ctx\n")
		sb.WriteString("\t_ = pagination\n")
		sb.WriteString("\tw.Header().Set(\"Content-Type\", \"application/json\")\n")
		sb.WriteString("\tjson.NewEncoder(w).Encode(map[string]interface{}{\n")
		sb.WriteString("\t\t\"data\": []interface{}{},\n")
		sb.WriteString("\t\t\"meta\": map[string]interface{}{\n")
		sb.WriteString("\t\t\t\"page\": pagination.Page,\n")
		sb.WriteString("\t\t\t\"per_page\": pagination.PerPage,\n")
		sb.WriteString("\t\t\t\"total\": 0,\n")
		sb.WriteString("\t\t},\n")
		sb.WriteString("\t})\n")

	case OpCreate:
		sb.WriteString("\t// TODO: Parse request body\n")
		sb.WriteString("\t// TODO: Validate input\n")
		sb.WriteString("\t// TODO: Create resource\n")
		sb.WriteString("\t_ = ctx\n")
		sb.WriteString("\tw.Header().Set(\"Content-Type\", \"application/json\")\n")
		sb.WriteString("\tw.WriteHeader(http.StatusCreated)\n")
		sb.WriteString("\tjson.NewEncoder(w).Encode(map[string]interface{}{\n")
		sb.WriteString("\t\t\"message\": \"Created\",\n")
		sb.WriteString("\t})\n")

	case OpShow:
		sb.WriteString(fmt.Sprintf("\t// Extract ID parameter\n"))
		if schema.PrimaryKeyType == "uuid" {
			sb.WriteString("\tid, err := params.PathParamUUID(\"id\")\n")
			sb.WriteString("\tif err != nil {\n")
			sb.WriteString("\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n")
			sb.WriteString("\t\treturn\n")
			sb.WriteString("\t}\n\n")
		} else {
			sb.WriteString("\tid := params.PathParam(\"id\")\n\n")
		}
		sb.WriteString("\t// TODO: Fetch resource by ID\n")
		sb.WriteString("\t_ = ctx\n")
		sb.WriteString("\t_ = id\n")
		sb.WriteString("\tw.Header().Set(\"Content-Type\", \"application/json\")\n")
		sb.WriteString("\tjson.NewEncoder(w).Encode(map[string]interface{}{\n")
		sb.WriteString("\t\t\"message\": \"Resource found\",\n")
		sb.WriteString("\t})\n")

	case OpUpdate, OpPatch:
		sb.WriteString(fmt.Sprintf("\t// Extract ID parameter\n"))
		if schema.PrimaryKeyType == "uuid" {
			sb.WriteString("\tid, err := params.PathParamUUID(\"id\")\n")
			sb.WriteString("\tif err != nil {\n")
			sb.WriteString("\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n")
			sb.WriteString("\t\treturn\n")
			sb.WriteString("\t}\n\n")
		} else {
			sb.WriteString("\tid := params.PathParam(\"id\")\n\n")
		}
		sb.WriteString("\t// TODO: Parse request body\n")
		sb.WriteString("\t// TODO: Validate input\n")
		sb.WriteString("\t// TODO: Update resource\n")
		sb.WriteString("\t_ = ctx\n")
		sb.WriteString("\t_ = id\n")
		sb.WriteString("\tw.Header().Set(\"Content-Type\", \"application/json\")\n")
		sb.WriteString("\tjson.NewEncoder(w).Encode(map[string]interface{}{\n")
		sb.WriteString("\t\t\"message\": \"Updated\",\n")
		sb.WriteString("\t})\n")

	case OpDelete:
		sb.WriteString(fmt.Sprintf("\t// Extract ID parameter\n"))
		if schema.PrimaryKeyType == "uuid" {
			sb.WriteString("\tid, err := params.PathParamUUID(\"id\")\n")
			sb.WriteString("\tif err != nil {\n")
			sb.WriteString("\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n")
			sb.WriteString("\t\treturn\n")
			sb.WriteString("\t}\n\n")
		} else {
			sb.WriteString("\tid := params.PathParam(\"id\")\n\n")
		}
		sb.WriteString("\t// TODO: Delete resource\n")
		sb.WriteString("\t_ = ctx\n")
		sb.WriteString("\t_ = id\n")
		sb.WriteString("\tw.WriteHeader(http.StatusNoContent)\n")
	}

	sb.WriteString("}\n")
	return sb.String()
}

// Helper functions for code generation

func lowerFirst(s string) string {
	if s == "" {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func capitalize(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}
