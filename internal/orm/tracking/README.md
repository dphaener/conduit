# Change Tracking Package

The `tracking` package provides change tracking functionality for Conduit ORM resources. It enables efficient UPDATE queries by detecting which fields have been modified.

## Features

- **Field Change Detection**: Track which fields have been modified
- **Original Value Access**: Retrieve previous values of changed fields
- **Conditional Logic**: Check if fields changed to/from specific values
- **Thread-Safe**: Safe for concurrent access with RWMutex
- **Efficient Updates**: Generate UPDATE queries with only changed fields
- **No-Op Detection**: Skip database updates when nothing changed

## Usage

### Basic Change Tracking

```go
import "github.com/conduit-lang/conduit/internal/orm/tracking"

// Original state from database
original := map[string]interface{}{
    "id":     1,
    "title":  "Old Title",
    "status": "draft",
}

// Current state after modifications
current := map[string]interface{}{
    "id":     1,
    "title":  "New Title",
    "status": "draft",
}

// Create tracker
tracker := tracking.NewChangeTracker(original, current)

// Check if field changed
if tracker.Changed("title") {
    oldValue := tracker.PreviousValue("title")
    newValue := tracker.CurrentValue("title")
    fmt.Printf("Title changed from %v to %v\n", oldValue, newValue)
}

// Get all changed fields
changedFields := tracker.ChangedFields() // ["title"]

// Check if anything changed
if tracker.HasChanges() {
    // Get only changed data for UPDATE
    updates := tracker.GetChangedData()
    // Only includes: {"title": "New Title"}
}
```

### Conditional Checks

```go
// Check if field changed to a specific value
if tracker.ChangedTo("status", "published") {
    // Set published_at timestamp
    record["published_at"] = time.Now()
}

// Check if field changed from a specific value
if tracker.ChangedFrom("status", "draft") {
    // Log status promotion
    log.Info("Status promoted from draft")
}
```

### Integration with CRUD

```go
// In update operation
changeTracker := tracking.NewChangeTracker(existing, record)
record["__changes__"] = changeTracker

// Later, get only changed fields for UPDATE
if changeTracker.HasChanges() {
    changedData := changeTracker.GetChangedData()
    // Execute UPDATE with only changed fields
} else {
    // Skip UPDATE - nothing changed
}

// After successful save
changeTracker.Reset()
```

## API Reference

### Constructor

- `NewChangeTracker(original, current map[string]interface{}) *ChangeTracker`
  - Creates a new change tracker
  - `original`: Initial state (from database)
  - `current`: Current state (with modifications)

### Query Methods

- `Changed(field string) bool`
  - Returns true if the field has changed

- `ChangedFields() []string`
  - Returns list of all changed field names

- `HasChanges() bool`
  - Returns true if any fields changed

- `PreviousValue(field string) interface{}`
  - Returns the original value of a field

- `CurrentValue(field string) interface{}`
  - Returns the current value of a field

- `GetChange(field string) *FieldChange`
  - Returns detailed change information for a field

- `Changes() map[string]*FieldChange`
  - Returns all changes as a map

### Conditional Methods

- `ChangedTo(field string, value interface{}) bool`
  - Returns true if field changed to the specified value

- `ChangedFrom(field string, value interface{}) bool`
  - Returns true if field changed from the specified value

### Update Methods

- `SetFieldValue(field string, value interface{})`
  - Updates a field value and recomputes changes

- `GetChangedData() map[string]interface{}`
  - Returns map of only changed fields with new values
  - Useful for efficient UPDATE queries

- `Reset()`
  - Clears all tracked changes
  - Updates original state to current state
  - Call after successful save

## Thread Safety

All methods are thread-safe using `sync.RWMutex`:
- Read operations (Changed, PreviousValue, etc.) use RLock
- Write operations (SetFieldValue, Reset) use exclusive Lock

## Performance

- **Memory**: O(n) where n = number of fields
- **Time**: O(n) for initial computation, O(1) for queries
- **No-Op Detection**: Skips database UPDATE if no changes
- **Efficient Updates**: Only changed fields in UPDATE statement

## Internal Fields

The following fields are automatically ignored:
- `__changes__`: Internal tracking metadata

## Testing

Run tests with:
```bash
go test -v -cover ./internal/orm/tracking/
```

Current coverage: 98.8%

## Example: Generated Resource Methods

The code generator creates convenience methods on resources:

```go
// Generated by codegen
func (p *Post) TitleChanged() bool {
    return p.changeTracker().Changed("title")
}

func (p *Post) PreviousTitle() string {
    val := p.changeTracker().PreviousValue("title")
    if v, ok := val.(string); ok {
        return v
    }
    return ""
}

func (p *Post) SetTitle(value string) {
    p.Title = value
    p.changeTracker().SetFieldValue("title", value)
}
```

## Design Decisions

1. **Map-based API**: Works with `map[string]interface{}` for flexibility
2. **Deep Equality**: Uses `reflect.DeepEqual` for accurate comparison
3. **Immutability**: Original values are never modified
4. **Thread-Safety**: All operations are synchronized
5. **Nil Handling**: Gracefully handles nil maps and values
6. **Field Deletion**: Detects when fields are removed

## Future Enhancements

Potential future additions (not in MVP):
- Audit trail integration
- Change events/callbacks
- Nested struct tracking
- Diff snapshots for rollback
- Custom comparison functions
