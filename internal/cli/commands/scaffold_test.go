package commands

import (
	"os"
	"path/filepath"
	"testing"
)

func TestScaffoldCommand(t *testing.T) {
	tests := []struct {
		name          string
		template      string
		wantFiles     []string
		wantErr       bool
		setupProject  bool
		createConflict string
	}{
		{
			name:         "todo template success",
			template:     "todo",
			wantFiles:    []string{"todo.cdt"},
			wantErr:      false,
			setupProject: true,
		},
		{
			name:         "blog template success",
			template:     "blog",
			wantFiles:    []string{"user.cdt", "post.cdt", "comment.cdt"},
			wantErr:      false,
			setupProject: true,
		},
		{
			name:         "api template success",
			template:     "api",
			wantFiles:    []string{"user.cdt", "api_key.cdt"},
			wantErr:      false,
			setupProject: true,
		},
		{
			name:         "unknown template",
			template:     "unknown",
			wantFiles:    nil,
			wantErr:      true,
			setupProject: true,
		},
		{
			name:         "no conduit.yaml",
			template:     "todo",
			wantFiles:    nil,
			wantErr:      true,
			setupProject: false,
		},
		{
			name:           "file conflict",
			template:       "todo",
			wantFiles:      nil,
			wantErr:        true,
			setupProject:   true,
			createConflict: "todo.cdt",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create temporary directory
			tmpDir := t.TempDir()
			oldDir, err := os.Getwd()
			if err != nil {
				t.Fatal(err)
			}
			defer os.Chdir(oldDir)

			if err := os.Chdir(tmpDir); err != nil {
				t.Fatal(err)
			}

			// Setup project if needed
			if tt.setupProject {
				if err := os.WriteFile("conduit.yaml", []byte("project:\n  name: test\n"), 0644); err != nil {
					t.Fatal(err)
				}
			}

			// Create conflicting file if specified
			if tt.createConflict != "" {
				resourcesDir := filepath.Join("app", "resources")
				if err := os.MkdirAll(resourcesDir, 0755); err != nil {
					t.Fatal(err)
				}
				conflictPath := filepath.Join(resourcesDir, tt.createConflict)
				if err := os.WriteFile(conflictPath, []byte("existing content"), 0644); err != nil {
					t.Fatal(err)
				}
			}

			// Run command
			cmd := NewScaffoldCommand()
			cmd.SetArgs([]string{tt.template})
			err = cmd.Execute()

			// Check error expectation
			if (err != nil) != tt.wantErr {
				t.Errorf("Execute() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			// If we expected an error, we're done
			if tt.wantErr {
				return
			}

			// Verify files were created
			resourcesDir := filepath.Join("app", "resources")
			for _, filename := range tt.wantFiles {
				filePath := filepath.Join(resourcesDir, filename)
				if _, err := os.Stat(filePath); os.IsNotExist(err) {
					t.Errorf("Expected file %s was not created", filename)
				}

				// Read file and verify it has content
				content, err := os.ReadFile(filePath)
				if err != nil {
					t.Errorf("Failed to read %s: %v", filename, err)
				}
				if len(content) == 0 {
					t.Errorf("File %s is empty", filename)
				}

				// Verify it has the generation comment
				contentStr := string(content)
				if !contains(contentStr, "Generated by: conduit scaffold") {
					t.Errorf("File %s missing generation comment", filename)
				}
			}
		})
	}
}

func TestScaffoldTemplateContent(t *testing.T) {
	tests := []struct {
		name        string
		templateFn  func() string
		wantStrings []string
	}{
		{
			name:       "todo template content",
			templateFn: getTodoTemplate,
			wantStrings: []string{
				"resource Todo",
				"id: uuid! @primary @auto",
				"title: string!",
				"slug: string! @unique",
				"@before create",
				"String.slugify",
				"Generated by: conduit scaffold todo",
			},
		},
		{
			name:       "user template content",
			templateFn: getUserTemplate,
			wantStrings: []string{
				"resource User",
				"id: uuid! @primary @auto",
				"email: string! @unique",
				"password_hash: string!",
				"Generated by: conduit scaffold blog",
			},
		},
		{
			name:       "post template content",
			templateFn: getPostTemplate,
			wantStrings: []string{
				"resource Post",
				"author: User!",
				"foreign_key: \"author_id\"",
				"on_delete: restrict",
				"Generated by: conduit scaffold blog",
			},
		},
		{
			name:       "comment template content",
			templateFn: getCommentTemplate,
			wantStrings: []string{
				"resource Comment",
				"post: Post!",
				"author: User!",
				"on_delete: cascade",
				"Generated by: conduit scaffold blog",
			},
		},
		{
			name:       "api user template content",
			templateFn: getAPIUserTemplate,
			wantStrings: []string{
				"resource User",
				"email_verified: bool!",
				"api_calls_count: int!",
				"Generated by: conduit scaffold api",
			},
		},
		{
			name:       "api key template content",
			templateFn: getAPIKeyTemplate,
			wantStrings: []string{
				"resource APIKey",
				"key_hash: string! @unique",
				"scopes: string!",
				"user: User!",
				"Generated by: conduit scaffold api",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			content := tt.templateFn()
			for _, want := range tt.wantStrings {
				if !contains(content, want) {
					t.Errorf("Template missing expected string: %q", want)
				}
			}
		})
	}
}

func TestScaffoldTemplatesExist(t *testing.T) {
	// Verify all documented templates are registered
	expectedTemplates := []string{"todo", "blog", "api"}
	for _, name := range expectedTemplates {
		if _, exists := scaffoldTemplates[name]; !exists {
			t.Errorf("Expected template %q not registered", name)
		}
	}
}

func TestScaffoldCommandHelp(t *testing.T) {
	cmd := NewScaffoldCommand()

	// Verify command has proper help text
	if cmd.Short == "" {
		t.Error("Command Short description is empty")
	}
	if cmd.Long == "" {
		t.Error("Command Long description is empty")
	}

	// Verify help text mentions all templates
	helpText := cmd.Long
	expectedMentions := []string{"todo", "blog", "api"}
	for _, mention := range expectedMentions {
		if !contains(helpText, mention) {
			t.Errorf("Help text missing template mention: %q", mention)
		}
	}
}

func TestGenerateScaffoldFunctions(t *testing.T) {
	tests := []struct {
		name     string
		fn       func(string) error
		wantFiles []string
	}{
		{
			name:     "generateTodoScaffold",
			fn:       generateTodoScaffold,
			wantFiles: []string{"todo.cdt"},
		},
		{
			name:     "generateBlogScaffold",
			fn:       generateBlogScaffold,
			wantFiles: []string{"user.cdt", "post.cdt", "comment.cdt"},
		},
		{
			name:     "generateAPIScaffold",
			fn:       generateAPIScaffold,
			wantFiles: []string{"user.cdt", "api_key.cdt"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tmpDir := t.TempDir()
			resourcesDir := filepath.Join(tmpDir, "resources")
			if err := os.MkdirAll(resourcesDir, 0755); err != nil {
				t.Fatal(err)
			}

			// Generate scaffold
			if err := tt.fn(resourcesDir); err != nil {
				t.Fatalf("Generate function failed: %v", err)
			}

			// Verify files exist
			for _, filename := range tt.wantFiles {
				filePath := filepath.Join(resourcesDir, filename)
				if _, err := os.Stat(filePath); os.IsNotExist(err) {
					t.Errorf("Expected file %s was not created", filename)
				}
			}
		})
	}
}

func TestWriteScaffoldFilesConflict(t *testing.T) {
	tmpDir := t.TempDir()
	resourcesDir := filepath.Join(tmpDir, "resources")
	if err := os.MkdirAll(resourcesDir, 0755); err != nil {
		t.Fatal(err)
	}

	// Create an existing file
	existingFile := filepath.Join(resourcesDir, "test.cdt")
	if err := os.WriteFile(existingFile, []byte("existing"), 0644); err != nil {
		t.Fatal(err)
	}

	// Try to write scaffold with conflict
	files := map[string]string{
		"test.cdt": "new content",
	}

	err := writeScaffoldFiles(resourcesDir, files)
	if err == nil {
		t.Error("Expected error for file conflict, got nil")
	}

	// Verify original file wasn't overwritten
	content, err := os.ReadFile(existingFile)
	if err != nil {
		t.Fatal(err)
	}
	if string(content) != "existing" {
		t.Error("Existing file was modified despite conflict")
	}
}

func TestTemplateValidSyntax(t *testing.T) {
	// This test verifies that templates have valid Conduit syntax patterns
	templates := []struct {
		name     string
		content  string
	}{
		{"todo", getTodoTemplate()},
		{"user", getUserTemplate()},
		{"post", getPostTemplate()},
		{"comment", getCommentTemplate()},
		{"api_user", getAPIUserTemplate()},
		{"api_key", getAPIKeyTemplate()},
	}

	for _, tt := range templates {
		t.Run(tt.name, func(t *testing.T) {
			// Check for required patterns
			requiredPatterns := []string{
				"resource ",
				"id: uuid! @primary @auto",
				"created_at: timestamp! @auto",
			}

			for _, pattern := range requiredPatterns {
				if !contains(tt.content, pattern) {
					t.Errorf("Template missing required pattern: %q", pattern)
				}
			}

			// Check for explicit nullability (! or ?)
			// This is a basic check - real validation would need a parser
			lines := splitLines(tt.content)
			for i, line := range lines {
				// Skip comments and empty lines
				trimmed := trimSpace(line)
				if trimmed == "" || startsWith(trimmed, "//") || startsWith(trimmed, "///") {
					continue
				}

				// If line has a colon (field definition), verify nullability
				if contains(line, ":") && !contains(line, "{") && !contains(line, "}") {
					// After the colon, there should be a type with ! or ?
					if contains(line, ": ") {
						afterColon := line[indexOf(line, ": ")+2:]
						// Should have ! or ? in the type declaration
						if !contains(afterColon, "!") && !contains(afterColon, "?") && !startsWith(trimmed, "@") {
							// Allow relationship blocks and annotations
							if !contains(line, "foreign_key") && !contains(line, "on_delete") {
								t.Errorf("Line %d missing explicit nullability: %s", i+1, line)
							}
						}
					}
				}
			}
		})
	}
}

// Helper functions
func splitLines(s string) []string {
	var lines []string
	start := 0
	for i := 0; i < len(s); i++ {
		if s[i] == '\n' {
			lines = append(lines, s[start:i])
			start = i + 1
		}
	}
	if start < len(s) {
		lines = append(lines, s[start:])
	}
	return lines
}

func trimSpace(s string) string {
	start := 0
	end := len(s)
	for start < end && (s[start] == ' ' || s[start] == '\t' || s[start] == '\n' || s[start] == '\r') {
		start++
	}
	for end > start && (s[end-1] == ' ' || s[end-1] == '\t' || s[end-1] == '\n' || s[end-1] == '\r') {
		end--
	}
	return s[start:end]
}

func startsWith(s, prefix string) bool {
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
}

func indexOf(s, substr string) int {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return i
		}
	}
	return -1
}

// TestScaffoldIntegration tests the complete scaffold â†’ build pipeline
// This verifies that all scaffolds generate code that actually compiles
func TestScaffoldIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	// Check if CONDUIT_ROOT is set (required for build)
	conduitRoot := os.Getenv("CONDUIT_ROOT")
	if conduitRoot == "" {
		t.Skip("Skipping integration test: CONDUIT_ROOT not set")
	}

	templates := []struct {
		name      string
		template  string
		wantFiles []string
	}{
		{
			name:      "todo scaffold builds",
			template:  "todo",
			wantFiles: []string{"todo.cdt"},
		},
		{
			name:      "blog scaffold builds",
			template:  "blog",
			wantFiles: []string{"user.cdt", "post.cdt", "comment.cdt"},
		},
		{
			name:      "api scaffold builds",
			template:  "api",
			wantFiles: []string{"user.cdt", "api_key.cdt"},
		},
	}

	for _, tt := range templates {
		t.Run(tt.name, func(t *testing.T) {
			// Create temporary project directory
			tmpDir := t.TempDir()
			oldDir, err := os.Getwd()
			if err != nil {
				t.Fatal(err)
			}
			defer os.Chdir(oldDir)

			if err := os.Chdir(tmpDir); err != nil {
				t.Fatal(err)
			}

			// Create conduit.yaml
			conduitYAML := `project:
  name: test-scaffold
  version: 0.1.0
server:
  port: 3000
database:
  type: postgres
  host: localhost
  port: 5432
  name: test_db
  user: postgres
  password: postgres
`
			if err := os.WriteFile("conduit.yaml", []byte(conduitYAML), 0644); err != nil {
				t.Fatal(err)
			}

			// Run scaffold command
			scaffoldCmd := NewScaffoldCommand()
			scaffoldCmd.SetArgs([]string{tt.template})
			if err := scaffoldCmd.Execute(); err != nil {
				t.Fatalf("Scaffold command failed: %v", err)
			}

			// Verify files were created
			resourcesDir := filepath.Join("app", "resources")
			for _, filename := range tt.wantFiles {
				filePath := filepath.Join(resourcesDir, filename)
				if _, err := os.Stat(filePath); os.IsNotExist(err) {
					t.Errorf("Expected file %s was not created", filename)
				}
			}

			// Run build command
			buildCmd := NewBuildCommand()
			buildCmd.SetArgs([]string{})
			if err := buildCmd.Execute(); err != nil {
				t.Fatalf("Build command failed: %v", err)
			}

			// Verify binary was created
			binaryPath := filepath.Join("build", "app")
			if _, err := os.Stat(binaryPath); os.IsNotExist(err) {
				t.Errorf("Binary %s was not created", binaryPath)
			}

			// Verify binary is executable
			info, err := os.Stat(binaryPath)
			if err != nil {
				t.Errorf("Failed to stat binary: %v", err)
			} else {
				// Check if file is executable (Unix-style check)
				mode := info.Mode()
				if mode&0111 == 0 {
					t.Errorf("Binary is not executable: %v", mode)
				}
			}
		})
	}
}
