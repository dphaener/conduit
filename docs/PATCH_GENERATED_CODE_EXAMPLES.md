# PATCH Endpoints - Generated Code Examples

This document shows examples of the code generated by the Conduit compiler for PATCH endpoints.

## Example Resource Definition

```conduit
resource Post {
  id: uuid! @primary @auto
  title: string! @min(5) @max(200)
  body: text! @min(100)
  status: string! @default("draft")
  published_at: timestamp?
  created_at: timestamp! @auto
  updated_at: timestamp! @auto_update
}
```

## Generated Handler Code

The compiler generates a `PatchPostHandler` function in `handlers/handlers.go`:

```go
// PatchPostHandler handles PATCH /posts/{id} - partially update an existing post
func PatchPostHandler(db *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		// Parse ID from URL
		idStr := chi.URLParam(r, "id")
		id, err := uuid.Parse(idStr)
		if err != nil {
			respondWithError(w, "Invalid ID", http.StatusBadRequest)
			return
		}

		// Fetch existing post
		existing, err := models.FindPostByID(ctx, db, id)
		if err != nil {
			if err == sql.ErrNoRows {
				if response.IsJSONAPI(r) {
					response.RenderJSONAPIError(w, http.StatusNotFound, fmt.Errorf("Not found"))
				} else {
					respondWithError(w, "Not found", http.StatusNotFound)
				}
				return
			}
			if response.IsJSONAPI(r) {
				response.RenderJSONAPIError(w, http.StatusInternalServerError, fmt.Errorf("Failed to find post: %v", err))
			} else {
				respondWithError(w, fmt.Sprintf("Failed to find post: %v", err), http.StatusInternalServerError)
			}
			return
		}

		// Check if JSON:API format is requested
		if response.IsJSONAPI(r) {
			// Validate Content-Type
			if !response.ValidateJSONAPIContentType(w, r) {
				return
			}

			// Limit request body size to prevent DoS attacks (10MB default)
			r.Body = http.MaxBytesReader(w, r.Body, 10<<20)

			// Read request body
			body, err := io.ReadAll(r.Body)
			if err != nil {
				var maxBytesError *http.MaxBytesError
				if errors.As(err, &maxBytesError) {
					response.RenderJSONAPIError(w, http.StatusRequestEntityTooLarge, fmt.Errorf("Request body too large (max 10MB)"))
					return
				}
				response.RenderJSONAPIError(w, http.StatusBadRequest, fmt.Errorf("Failed to read request body: %v", err))
				return
			}

			// Patch post (includes validation and hooks)
			if err := existing.Patch(ctx, db, body); err != nil {
				response.RenderJSONAPIError(w, http.StatusUnprocessableEntity, err)
				return
			}

			// Render JSON:API response
			if err := response.RenderJSONAPI(w, http.StatusOK, existing); err != nil {
				response.RenderJSONAPIError(w, http.StatusInternalServerError, fmt.Errorf("Failed to encode response: %v", err))
				return
			}
		} else {
			// Legacy JSON format
			body, err := io.ReadAll(r.Body)
			if err != nil {
				respondWithError(w, fmt.Sprintf("Failed to read request body: %v", err), http.StatusBadRequest)
				return
			}

			// Patch post (includes validation and hooks)
			if err := existing.Patch(ctx, db, body); err != nil {
				respondWithError(w, fmt.Sprintf("Failed to patch post: %v", err), http.StatusUnprocessableEntity)
				return
			}

			w.Header().Set("Content-Type", "application/json")
			if err := json.NewEncoder(w).Encode(existing); err != nil {
				respondWithError(w, fmt.Sprintf("Failed to encode response: %v", err), http.StatusInternalServerError)
				return
			}
		}
	}
}
```

## Generated Model Method

The compiler generates a `Patch` method in `models/post.go`:

```go
// Patch partially updates an existing Post in the database
func (p *Post) Patch(ctx context.Context, db *sql.DB, partialJSON []byte) error {
	// Parse partial JSON to identify provided fields
	var partialData map[string]interface{}
	if err := json.Unmarshal(partialJSON, &partialData); err != nil {
		return fmt.Errorf("invalid JSON: %w", err)
	}

	// Reject empty PATCH requests
	if len(partialData) == 0 {
		return fmt.Errorf("empty PATCH request: no fields provided")
	}

	// Validate no read-only fields are being updated
	readOnlyFields := map[string]bool{
		"id":         true,
		"created_at": true,
		"updated_at": true,
	}
	for field := range partialData {
		if readOnlyFields[field] {
			return fmt.Errorf("field '%s' is read-only and cannot be updated", field)
		}
	}

	// Build list of valid fields
	validFields := map[string]bool{
		"title":        true,
		"body":         true,
		"status":       true,
		"published_at": true,
	}

	// Validate no unknown fields
	for field := range partialData {
		if !validFields[field] && !readOnlyFields[field] {
			// Build list of valid field names for error message
			validFieldNames := make([]string, 0, len(validFields))
			for f := range validFields {
				validFieldNames = append(validFieldNames, f)
			}
			return fmt.Errorf("unknown field '%s': valid fields are: %v", field, validFieldNames)
		}
	}

	// Apply partial updates to existing resource
	if err := json.Unmarshal(partialJSON, &p); err != nil {
		return fmt.Errorf("failed to apply partial update: %w", err)
	}

	// Validate the merged result
	if err := p.Validate(); err != nil {
		return fmt.Errorf("validation failed: %w", err)
	}

	// Update auto_update fields
	p.UpdatedAt = time.Now()

	query := `UPDATE posts SET title = $1, body = $2, status = $3, published_at = $4, updated_at = $5 WHERE id = $6`

	_, err := db.ExecContext(ctx, query, p.Title, p.Body, p.Status, p.PublishedAt, p.UpdatedAt, p.ID)
	if err != nil {
		return fmt.Errorf("failed to patch post: %w", err)
	}

	return nil
}
```

## Generated Route Registration

The compiler adds PATCH route registration in `handlers/handlers.go`:

```go
// RegisterPostRoutes registers all routes for posts
func RegisterPostRoutes(r chi.Router, db *sql.DB) {
	r.Get("/posts", ListPostHandler(db))
	r.Post("/posts", CreatePostHandler(db))
	r.Get("/posts/{id}", GetPostHandler(db))
	r.Put("/posts/{id}", UpdatePostHandler(db))
	r.Patch("/posts/{id}", PatchPostHandler(db))  // <-- NEW
	r.Delete("/posts/{id}", DeletePostHandler(db))
}
```

## Request/Response Examples

### Example 1: Update Single Field

**Request:**
```bash
PATCH /api/posts/550e8400-e29b-41d4-a716-446655440000
Content-Type: application/json

{
  "status": "published"
}
```

**Database Operations:**
1. `SELECT * FROM posts WHERE id = $1` (fetch existing)
2. Merge: `existing.status = "published"`
3. Validate: Check all constraints on merged resource
4. `UPDATE posts SET title = $1, body = $2, status = $3, ... WHERE id = $6`

**Response (200 OK):**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "title": "My Blog Post",
  "body": "This is the content...",
  "status": "published",
  "published_at": null,
  "created_at": "2025-11-02T10:00:00Z",
  "updated_at": "2025-11-03T14:30:00Z"
}
```

### Example 2: Update Multiple Fields

**Request:**
```bash
PATCH /api/posts/550e8400-e29b-41d4-a716-446655440000
Content-Type: application/json

{
  "title": "Updated Title",
  "status": "published",
  "published_at": "2025-11-03T14:30:00Z"
}
```

**Response (200 OK):**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "title": "Updated Title",
  "body": "This is the content...",
  "status": "published",
  "published_at": "2025-11-03T14:30:00Z",
  "created_at": "2025-11-02T10:00:00Z",
  "updated_at": "2025-11-03T14:30:00Z"
}
```

### Example 3: Read-Only Field Error

**Request:**
```bash
PATCH /api/posts/550e8400-e29b-41d4-a716-446655440000
Content-Type: application/json

{
  "id": "different-uuid-here",
  "status": "published"
}
```

**Response (400 Bad Request):**
```json
{
  "error": "field 'id' is read-only and cannot be updated"
}
```

### Example 4: Unknown Field Error

**Request:**
```bash
PATCH /api/posts/550e8400-e29b-41d4-a716-446655440000
Content-Type: application/json

{
  "author_name": "John Doe",
  "status": "published"
}
```

**Response (400 Bad Request):**
```json
{
  "error": "unknown field 'author_name': valid fields are: [title, body, status, published_at]"
}
```

### Example 5: Empty PATCH Error

**Request:**
```bash
PATCH /api/posts/550e8400-e29b-41d4-a716-446655440000
Content-Type: application/json

{}
```

**Response (400 Bad Request):**
```json
{
  "error": "empty PATCH request: no fields provided"
}
```

### Example 6: Validation Error

**Request:**
```bash
PATCH /api/posts/550e8400-e29b-41d4-a716-446655440000
Content-Type: application/json

{
  "title": "abc"
}
```

**Response (422 Unprocessable Entity):**
```json
{
  "error": "validation failed: title must be at least 5 characters"
}
```

### Example 7: Resource Not Found

**Request:**
```bash
PATCH /api/posts/00000000-0000-0000-0000-000000000000
Content-Type: application/json

{
  "status": "published"
}
```

**Response (404 Not Found):**
```json
{
  "error": "Not found"
}
```

### Example 8: Set Nullable Field to Null

**Request:**
```bash
PATCH /api/posts/550e8400-e29b-41d4-a716-446655440000
Content-Type: application/json

{
  "published_at": null
}
```

**Response (200 OK):**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "title": "My Blog Post",
  "body": "This is the content...",
  "status": "draft",
  "published_at": null,
  "created_at": "2025-11-02T10:00:00Z",
  "updated_at": "2025-11-03T14:30:00Z"
}
```

## Code Flow Diagram

```
1. HTTP Request
   └─> PatchPostHandler
       ├─> Parse ID from URL
       ├─> FindPostByID (SELECT query)
       │   └─> Return 404 if not found
       ├─> Read request body
       └─> Call Post.Patch()
           ├─> Parse JSON to map
           ├─> Validate not empty
           ├─> Validate no read-only fields
           ├─> Validate no unknown fields
           ├─> Unmarshal to merge with existing
           ├─> Call Post.Validate()
           ├─> Update timestamps
           └─> Execute UPDATE query
       └─> Return complete resource
```

## Performance Characteristics

### Database Queries

**PATCH:**
- 1 SELECT (fetch existing)
- 1 UPDATE (save merged)
- **Total: 2 queries**

**PUT:**
- 1 UPDATE (overwrite)
- **Total: 1 query**

### Network Transfer

**Example: Update status field**

**PUT (Full Update):**
```json
{
  "title": "Long title here...",
  "body": "Very long body content here...",
  "status": "published",
  "published_at": null
}
```
Payload: ~500 bytes

**PATCH (Partial Update):**
```json
{
  "status": "published"
}
```
Payload: ~25 bytes

**Savings: 95%**

## Security Considerations

### Read-Only Fields

The generated code automatically protects these fields:
- `id` - Primary key
- `created_at` - Creation timestamp
- `updated_at` - Update timestamp
- Any field with `@auto` or `@auto_update` constraint

### Field Validation

All fields are validated according to their constraints:
- Required fields: Must be present in merged resource
- `@min`, `@max`: Applied to merged values
- `@unique`: Enforced at database level
- Type constraints: Enforced during JSON unmarshal

### SQL Injection Protection

All database operations use parameterized queries:
```go
db.ExecContext(ctx, query, p.Title, p.Body, p.Status, ...)
```

## Comparison with PUT

| Aspect | PUT | PATCH |
|--------|-----|-------|
| Payload Size | Full resource | Only changed fields |
| Database Queries | 1 UPDATE | 1 SELECT + 1 UPDATE |
| Validation | Full resource | Merged resource |
| Use Case | Replace entire resource | Update specific fields |
| Idempotency | Yes | Yes |
| HTTP Semantics | Replace | Partial modify |

## Best Practices

### When to Use PATCH

- Updating 1-3 fields in a large resource
- Frontend forms with individual field updates
- Mobile apps (minimize bandwidth)
- Real-time collaborative editing

### When to Use PUT

- Updating most/all fields
- Importing data from external systems
- Admin operations that replace entire resources
- When you already have the full resource loaded

## Future Enhancements

1. **Optimistic Locking**: Add ETag header support
2. **Selective UPDATE**: Only update changed fields in SQL
3. **Audit Trail**: Log which fields changed
4. **Batch PATCH**: Update multiple resources in one request
5. **JSON Patch RFC 6902**: Support more complex patch operations
